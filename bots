const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, StringSelectMenuBuilder, REST, Routes, SlashCommandBuilder } = require('discord.js');
const fs = require('fs');
const ms = require('ms');
const { MongoClient, ServerApiVersion } = require('mongodb');
require('dotenv').config();

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildVoiceStates
  ]
});

const commands = [
  new SlashCommandBuilder()
    .setName('help')
    .setDescription('Affiche l\'aide du bot de modÃ©ration'),
  new SlashCommandBuilder()
    .setName('config')
    .setDescription('Configure le bot')
    .addSubcommand(subcommand =>
      subcommand
        .setName('staff')
        .setDescription('DÃ©finit le rÃ´le staff')
        .addRoleOption(option =>
          option.setName('role')
            .setDescription('Le rÃ´le staff')
            .setRequired(true)))
    .addSubcommand(subcommand =>
      subcommand
        .setName('logs')
        .setDescription('DÃ©finit le canal de logs')
        .addChannelOption(option =>
          option.setName('channel')
            .setDescription('Le canal de logs')
            .setRequired(true))),
  new SlashCommandBuilder()
    .setName('tempmute')
    .setDescription('Mute temporairement un membre')
    .addUserOption(option =>
      option.setName('user')
        .setDescription('Le membre Ã  mute')
        .setRequired(true)),
  new SlashCommandBuilder()
    .setName('unmute')
    .setDescription('Retire le mute d\'un membre')
    .addUserOption(option =>
      option.setName('user')
        .setDescription('Le membre Ã  unmute')
        .setRequired(true)),
  new SlashCommandBuilder()
    .setName('ban')
    .setDescription('Bannit un membre')
    .addUserOption(option =>
      option.setName('user')
        .setDescription('Le membre Ã  bannir')
        .setRequired(true))
    .addStringOption(option =>
      option.setName('reason')
        .setDescription('La raison du ban')
        .setRequired(false)),
  new SlashCommandBuilder()
    .setName('unban')
    .setDescription('DÃ©bannit un membre')
    .addStringOption(option =>
      option.setName('userid')
        .setDescription('L\'ID du membre Ã  dÃ©bannir')
        .setRequired(true))
];

const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);

(async () => {
  if (!process.env.CLIENT_ID) {
    console.log('âš ï¸ CLIENT_ID non dÃ©fini. Les commandes slash ne seront pas enregistrÃ©es.');
    return;
  }
  try {
    console.log('ğŸ”„ Enregistrement des commandes slash...');

    await rest.put(
      Routes.applicationCommands(process.env.CLIENT_ID),
      { body: commands.map(command => command.toJSON()) },
    );

    console.log('âœ… Commandes slash enregistrÃ©es avec succÃ¨s.');
  } catch (error) {
    console.error('âŒ Erreur lors de l\'enregistrement des commandes:', error);
  }
})();

// Connexion MongoDB
const uri = process.env.MONGODB_URI || "mongodb+srv://akkro1234_db_user:<db_password>@cluster0.wwcryjd.mongodb.net/?appName=Cluster0";
const mongoClient = new MongoClient(uri, {
  serverApi: {
    version: ServerApiVersion.v1,
    strict: true,
    deprecationErrors: true,
  }
});

async function connectMongo() {
  try {
    await mongoClient.connect();
    await mongoClient.db("admin").command({ ping: 1 });
    console.log("âœ… Pinged your deployment. You successfully connected to MongoDB!");
  } catch (err) {
    console.error('âŒ Erreur MongoDB:', err);
  }
}

if (process.env.MONGODB_URI) {
  connectMongo();
} else {
  console.log('âš ï¸ MONGODB_URI non dÃ©fini - Utilisation du systÃ¨me de fichiers (donnÃ©es non persistantes)');
}

// Charger les donnÃ©es
let db = { mutes: [], config: { staffRoleId: '1423018980465049734', logsChannelId: '1423018982494961679' } };
async function loadDB() {
  if (mongoClient && mongoClient.topology && mongoClient.topology.isConnected()) {
    try {
      const database = mongoClient.db('discordbot');
      const collection = database.collection('botdata');
      const data = await collection.findOne({ _id: 'botdata' });
      if (data) {
        db = { config: data.config || db.config, mutes: data.mutes || [] };
      } else {
        // CrÃ©er le document par dÃ©faut
        await collection.insertOne({ _id: 'botdata', config: db.config, mutes: [] });
      }
    } catch (err) {
      console.error('Erreur chargement DB:', err);
    }
  } else {
    // Fallback to file
    try {
      if (fs.existsSync('data.json')) {
        const data = JSON.parse(fs.readFileSync('data.json', 'utf8'));
        db = { ...db, ...data };
      }
    } catch (err) {
      console.error('Erreur lecture data.json:', err);
    }
  }
}

async function saveDB() {
  if (mongoClient && mongoClient.topology && mongoClient.topology.isConnected()) {
    try {
      const database = mongoClient.db('discordbot');
      const collection = database.collection('botdata');
      await collection.replaceOne({ _id: 'botdata' }, { _id: 'botdata', config: db.config, mutes: db.mutes }, { upsert: true });
    } catch (err) {
      console.error('Erreur sauvegarde DB:', err);
    }
  } else {
    // Fallback to file
    try {
      fs.writeFileSync('data.json', JSON.stringify(db, null, 2));
    } catch (err) {
      console.error('Erreur sauvegarde data.json:', err);
    }
  }
}

function sendLog(guild, title, description, color) {
  try {
    const channel = guild.channels.cache.get(db.config.logsChannelId);
    if (!channel) return;

    const embed = new EmbedBuilder()
      .setTitle(title)
      .setDescription(description)
      .setColor(color)
      .setTimestamp();

    channel.send({ embeds: [embed] }).catch(err => {
      console.error('Erreur envoi log:', err.message);
    });
  } catch (err) {
    console.error('Erreur sendLog:', err.message);
  }
}

async function getMutedRole(guild) {
  try {
    let role = guild.roles.cache.find(r => r.name === 'Muted');
    if (!role) {
      role = await guild.roles.create({
        name: 'Muted',
        permissions: []
      });
      
      for (const channel of guild.channels.cache.values()) {
        await channel.permissionOverwrites.edit(role, {
          SendMessages: false,
          Speak: false,
          AddReactions: false
        }).catch(() => {});
      }
    }
    return role;
  } catch (err) {
    console.error('Erreur getMutedRole:', err.message);
    return null;
  }
}

async function applyTempMute(member, duration, reason, interaction = null) {
  try {
    const mutedRole = await getMutedRole(member.guild);
    if (!mutedRole) {
      if (interaction) {
        await interaction.reply({ content: 'âŒ Impossible de crÃ©er/trouver le rÃ´le Muted', ephemeral: true });
      }
      return false;
    }

    const savedRoles = member.roles.cache
      .filter(r => r.id !== member.guild.id && r.id !== mutedRole.id)
      .map(r => r.id);

    await member.roles.set([mutedRole.id]);
    
    if (member.voice.channel) {
      await member.voice.disconnect().catch(() => {});
    }

    db.mutes.push({
      userId: member.id,
      guildId: member.guild.id,
      roles: savedRoles,
      end: Date.now() + duration,
      reason: reason
    });
    saveDB();

    sendLog(
      member.guild,
      'ğŸ”‡ TempMute appliquÃ©',
      `ğŸ‘¤ Utilisateur : **${member.user.tag}**\nâ±ï¸ DurÃ©e : **${ms(duration, { long: true })}**\nğŸ“„ Raison : **${reason}**`,
      'Orange'
    );

    return true;
  } catch (err) {
    console.error('Erreur applyTempMute:', err.message);
    if (interaction) {
      await interaction.reply({ 
        content: `âŒ Erreur lors du mute: ${err.message === 'Missing Permissions' ? 'Permissions insuffisantes (le bot doit avoir un rÃ´le plus Ã©levÃ© que la cible)' : err.message}`, 
        ephemeral: true 
      }).catch(() => {});
    }
    return false;
  }
}

async function unmute(member, manual = false) {
  try {
    const data = db.mutes.find(m => m.userId === member.id && m.guildId === member.guild.id);
    if (!data) return false;

    const mutedRole = await getMutedRole(member.guild);
    if (mutedRole) {
      await member.roles.remove(mutedRole).catch(() => {});
    }
    
    for (const roleId of data.roles) {
      await member.roles.add(roleId).catch(() => {});
    }

    db.mutes = db.mutes.filter(m => !(m.userId === member.id && m.guildId === member.guild.id));
    saveDB();

    sendLog(
      member.guild,
      manual ? 'ğŸ”Š Unmute manuel' : 'ğŸ”Š Unmute automatique',
      `ğŸ‘¤ Utilisateur : **${member.user.tag}** a Ã©tÃ© unmute`,
      'Green'
    );

    return true;
  } catch (err) {
    console.error('Erreur unmute:', err.message);
    return false;
  }
}

setInterval(async () => {
  try {
    const now = Date.now();
    const expiredMutes = db.mutes.filter(m => m.end <= now);
    
    for (const mute of expiredMutes) {
      const guild = client.guilds.cache.get(mute.guildId);
      if (!guild) {
        db.mutes = db.mutes.filter(m => !(m.userId === mute.userId && m.guildId === mute.guildId));
        saveDB();
        continue;
      }
      
      const member = await guild.members.fetch(mute.userId).catch(() => null);
      if (member) {
        await unmute(member);
      } else {
        db.mutes = db.mutes.filter(m => !(m.userId === mute.userId && m.guildId === mute.guildId));
        saveDB();
      }
    }
  } catch (err) {
    console.error('Erreur timer unmute:', err.message);
  }
}, 10000);

client.once('clientReady', async () => {
  await loadDB();
  console.log(`âœ… Bot connectÃ© : ${client.user.tag}`);
  console.log(`ğŸ“Š Serveurs : ${client.guilds.cache.size}`);
});

client.on('error', err => {
  console.error('Erreur client Discord:', err.message);
});

process.on('unhandledRejection', err => {
  console.error('Erreur non gÃ©rÃ©e:', err.message);
});

client.on('messageCreate', async message => {
  try {
    if (message.author.bot || !message.content.startsWith(PREFIX)) return;
    if (!message.guild) return;

    const args = message.content.slice(PREFIX.length).trim().split(/ +/);
    const cmd = args.shift().toLowerCase();

    if (cmd !== 'help' && cmd !== 'config' && !message.member.roles.cache.has(db.config.staffRoleId)) {
      return;
    }

    if (cmd === 'help') {
      const embed = new EmbedBuilder()
        .setTitle('ğŸ›¡ï¸ Aide du bot de modÃ©ration')
        .setDescription('Voici les commandes disponibles sur le serveur :')
        .addFields(
          { name: 'ğŸ”‡ TempMute', value: '`/tempmute ID`\nMute temporairement un membre via un menu de sanctions.' },
          { name: 'ğŸ”Š Unmute', value: '`/unmute ID`\nRetire le mute d\'un membre.' },
          { name: 'ğŸ”¨ Ban', value: '`/ban ID raison`\nBannit un membre du serveur.' },
          { name: 'ğŸ”“ Unban', value: '`/unban ID`\nDÃ©bannit un membre via son ID.' },
          { name: 'âš™ï¸ Config', value: '`/config staff @role`\nDÃ©finit le rÃ´le staff.\n`/config logs #channel`\nDÃ©finit le canal de logs.' }
        )
        .setColor('Blue')
        .setFooter({ text: 'Bot de modÃ©ration â€¢ SÃ©curitÃ© active' });

      return message.channel.send({ embeds: [embed] }).catch(() => {});
    }

    if (cmd === 'config') {
      const subCmd = args[0];
      if (!subCmd) {
        return message.reply('âŒ Utilisation: `/config staff @role` ou `/config logs #channel`').catch(() => {});
      }

      if (subCmd === 'staff') {
        const role = message.mentions.roles.first();
        if (!role) {
          return message.reply('âŒ Mentionnez un rÃ´le: `/config staff @role`').catch(() => {});
        }
        db.config.staffRoleId = role.id;
        saveDB();
        sendLog(message.guild, 'âš™ï¸ Configuration', `ğŸ‘¤ RÃ´le staff dÃ©fini sur **${role.name}** par ${message.author.tag}`, 'Blue');
        return message.reply(`âœ… RÃ´le staff dÃ©fini sur **${role.name}**`).catch(() => {});
      }

      if (subCmd === 'logs') {
        const channel = message.mentions.channels.first();
        if (!channel) {
          return message.reply('âŒ Mentionnez un canal: `/config logs #channel`').catch(() => {});
        }
        db.config.logsChannelId = channel.id;
        saveDB();
        sendLog(message.guild, 'âš™ï¸ Configuration', `ğŸ“ Canal de logs dÃ©fini sur **${channel.name}** par ${message.author.tag}`, 'Blue');
        return message.reply(`âœ… Canal de logs dÃ©fini sur **${channel.name}**`).catch(() => {});
      }

      return message.reply('âŒ Sous-commande invalide. Utilisez `staff` ou `logs`').catch(() => {});
    }

    if (cmd === 'tempmute') {
      const userId = args[0];
      if (!userId) {
        return message.reply('âŒ Merci de fournir un **ID utilisateur**').catch(() => {});
      }

      const member = await message.guild.members.fetch(userId).catch(() => null);
      if (!member) {
        return message.reply('âŒ Utilisateur introuvable').catch(() => {});
      }

      if (member.id === message.author.id) {
        return message.reply('âŒ Vous ne pouvez pas vous mute vous-mÃªme').catch(() => {});
      }

      if (member.roles.cache.has(db.config.staffRoleId)) {
        return message.reply('âŒ Vous ne pouvez pas mute un membre du staff').catch(() => {});
      }

      const menu = new StringSelectMenuBuilder()
        .setCustomId(`mute_${member.id}`)
        .setPlaceholder('â±ï¸ Choisis la sanction')
        .addOptions([
          { label: 'Insulte lÃ©gÃ¨re', description: '20 minutes', value: 'insulte_legere_20m' },
          { label: 'Insulte grave', description: '50 minutes', value: 'insulte_grave_50m' },
          { label: 'Spam', description: '1 heure', value: 'spam_1h' },
          { label: 'Pub', description: '1 heure', value: 'pub_1h' },
          { label: 'BDSM', description: '2 heures', value: 'bdsm_2h' },
          { label: 'Comportement inappropriÃ©', description: '40 minutes', value: 'comportement_40m' }
        ]);

      const row = new ActionRowBuilder().addComponents(menu);

      return message.channel.send({
        content: `ğŸ”§ Sanction Ã  appliquer pour **${member.user.tag}**`,
        components: [row]
      }).catch(() => {});
    }

    if (cmd === 'unmute') {
      const userId = args[0];
      if (!userId) {
        return message.reply('âŒ Merci de fournir un **ID utilisateur**').catch(() => {});
      }

      const member = await message.guild.members.fetch(userId).catch(() => null);
      if (!member) {
        return message.reply('âŒ Utilisateur introuvable').catch(() => {});
      }

      const success = await unmute(member, true);
      if (success) {
        sendLog(message.guild, 'ğŸ”Š Unmute', `ğŸ‘¤ **${member.user.tag}** unmute par ${message.author.tag}`, 'Green');
        message.reply('âœ… Membre unmute avec succÃ¨s').catch(() => {});
      } else {
        message.reply('âŒ Ce membre n\'est pas mute ou une erreur est survenue').catch(() => {});
      }
    }

    if (cmd === 'ban') {
      const userId = args[0];
      if (!userId) {
        return message.reply('âŒ Merci de fournir un **ID utilisateur**').catch(() => {});
      }

      const reason = args.slice(1).join(' ') || 'Aucune raison';
      const member = await message.guild.members.fetch(userId).catch(() => null);
      
      if (!member) {
        return message.reply('âŒ Utilisateur introuvable').catch(() => {});
      }

      if (!member.bannable) {
        return message.reply('âŒ Je ne peux pas bannir ce membre (permissions insuffisantes)').catch(() => {});
      }

      try {
        await member.ban({ reason });
        sendLog(message.guild, 'ğŸ”¨ Ban', `ğŸ‘¤ **${member.user.tag}**\nğŸ“„ Raison : ${reason}\nğŸ‘® Par : ${message.author.tag}`, 'Red');
        message.reply(`âœ… **${member.user.tag}** a Ã©tÃ© banni`).catch(() => {});
      } catch (err) {
        message.reply(`âŒ Erreur lors du ban: ${err.message}`).catch(() => {});
      }
    }

    if (cmd === 'unban') {
      const userId = args[0];
      if (!userId) {
        return message.reply('âŒ ID requis').catch(() => {});
      }

      try {
        await message.guild.members.unban(userId);
        sendLog(message.guild, 'ğŸ”“ Unban', `ğŸ‘¤ Utilisateur ID : **${userId}**\nğŸ‘® Par : ${message.author.tag}`, 'Green');
        message.reply('âœ… Utilisateur dÃ©banni avec succÃ¨s').catch(() => {});
      } catch (err) {
        message.reply(`âŒ Erreur lors du unban: ${err.message}`).catch(() => {});
      }
    }
  } catch (err) {
    console.error('Erreur messageCreate:', err.message);
  }
});

client.on('interactionCreate', async interaction => {
  try {
    if (interaction.isChatInputCommand()) {
      if (interaction.commandName !== 'help' && !interaction.member.roles.cache.has(db.config.staffRoleId)) {
        return interaction.reply({ content: 'âŒ Vous n\'avez pas la permission d\'utiliser cette commande.', ephemeral: true });
      }

      if (interaction.commandName === 'help') {
        const embed = new EmbedBuilder()
          .setTitle('ğŸ›¡ï¸ Aide du bot de modÃ©ration')
          .setDescription('Voici les commandes disponibles sur le serveur :')
          .addFields(
            { name: 'ğŸ”‡ TempMute', value: '`/tempmute @user`\nMute temporairement un membre via un menu de sanctions.' },
            { name: 'ğŸ”Š Unmute', value: '`/unmute @user`\nRetire le mute d\'un membre.' },
            { name: 'ğŸ”¨ Ban', value: '`/ban @user [raison]`\nBannit un membre du serveur.' },
            { name: 'ğŸ”“ Unban', value: '`/unban <ID>`\nDÃ©bannit un membre via son ID.' },
            { name: 'âš™ï¸ Config', value: '`/config staff @role`\nDÃ©finit le rÃ´le staff.\n`/config logs #channel`\nDÃ©finit le canal de logs.' }
          )
          .setColor('Blue')
          .setFooter({ text: 'Bot de modÃ©ration â€¢ SÃ©curitÃ© active' });

        return interaction.reply({ embeds: [embed] });
      }

      if (interaction.commandName === 'config') {
        const subCmd = interaction.options.getSubcommand();
        if (subCmd === 'staff') {
          const role = interaction.options.getRole('role');
          db.config.staffRoleId = role.id;
          saveDB();
          sendLog(interaction.guild, 'âš™ï¸ Configuration', `ğŸ‘¤ RÃ´le staff dÃ©fini sur **${role.name}** par ${interaction.user.tag}`, 'Blue');
          return interaction.reply(`âœ… RÃ´le staff dÃ©fini sur **${role.name}**`);
        }
        if (subCmd === 'logs') {
          const channel = interaction.options.getChannel('channel');
          db.config.logsChannelId = channel.id;
          saveDB();
          sendLog(interaction.guild, 'âš™ï¸ Configuration', `ğŸ“ Canal de logs dÃ©fini sur **${channel.name}** par ${interaction.user.tag}`, 'Blue');
          return interaction.reply(`âœ… Canal de logs dÃ©fini sur **${channel.name}**`);
        }
      }

      if (interaction.commandName === 'tempmute') {
        const user = interaction.options.getUser('user');
        const member = await interaction.guild.members.fetch(user.id).catch(() => null);
        if (!member) {
          return interaction.reply({ content: 'âŒ Utilisateur introuvable', ephemeral: true });
        }

        if (member.id === interaction.user.id) {
          return interaction.reply({ content: 'âŒ Vous ne pouvez pas vous mute vous-mÃªme', ephemeral: true });
        }

        if (member.roles.cache.has(db.config.staffRoleId)) {
          return interaction.reply({ content: 'âŒ Vous ne pouvez pas mute un membre du staff', ephemeral: true });
        }

        const menu = new StringSelectMenuBuilder()
          .setCustomId(`mute_${member.id}`)
          .setPlaceholder('â±ï¸ Choisis la sanction')
          .addOptions([
            { label: 'Insulte lÃ©gÃ¨re', description: '20 minutes', value: 'insulte_legere_20m' },
            { label: 'Insulte grave', description: '50 minutes', value: 'insulte_grave_50m' },
            { label: 'Spam', description: '1 heure', value: 'spam_1h' },
            { label: 'Pub', description: '1 heure', value: 'pub_1h' },
            { label: 'BDSM', description: '2 heures', value: 'bdsm_2h' },
            { label: 'Comportement inappropriÃ©', description: '40 minutes', value: 'comportement_40m' }
          ]);

        const row = new ActionRowBuilder().addComponents(menu);

        return interaction.reply({
          content: `ğŸ”§ Sanction Ã  appliquer pour **${member.user.tag}**`,
          components: [row]
        });
      }

      if (interaction.commandName === 'unmute') {
        const user = interaction.options.getUser('user');
        const member = await interaction.guild.members.fetch(user.id).catch(() => null);
        if (!member) {
          return interaction.reply({ content: 'âŒ Utilisateur introuvable', ephemeral: true });
        }

        const success = await unmute(member, false);
        if (success) {
          sendLog(interaction.guild, 'ğŸ”Š Unmute', `ğŸ‘¤ **${member.user.tag}** unmute par ${interaction.user.tag}`, 'Green');
          return interaction.reply('âœ… Membre unmute avec succÃ¨s');
        } else {
          return interaction.reply('âŒ Ce membre n\'est pas mute ou une erreur est survenue');
        }
      }

      if (interaction.commandName === 'ban') {
        const user = interaction.options.getUser('user');
        const reason = interaction.options.getString('reason') || 'Aucune raison';
        const member = await interaction.guild.members.fetch(user.id).catch(() => null);
        
        if (!member) {
          return interaction.reply({ content: 'âŒ Utilisateur introuvable', ephemeral: true });
        }

        if (!member.bannable) {
          return interaction.reply({ content: 'âŒ Je ne peux pas bannir ce membre (permissions insuffisantes)', ephemeral: true });
        }

        try {
          await member.ban({ reason });
          sendLog(interaction.guild, 'ğŸ”¨ Ban', `ğŸ‘¤ **${member.user.tag}**\nğŸ“„ Raison : ${reason}\nğŸ‘® Par : ${interaction.user.tag}`, 'Red');
          return interaction.reply(`âœ… **${member.user.tag}** a Ã©tÃ© banni`);
        } catch (err) {
          return interaction.reply(`âŒ Erreur lors du ban: ${err.message}`);
        }
      }

      if (interaction.commandName === 'unban') {
        const userId = interaction.options.getString('userid');

        try {
          await interaction.guild.members.unban(userId);
          sendLog(interaction.guild, 'ğŸ”“ Unban', `ğŸ‘¤ Utilisateur ID : **${userId}**\nğŸ‘® Par : ${interaction.user.tag}`, 'Green');
          return interaction.reply('âœ… Utilisateur dÃ©banni avec succÃ¨s');
        } catch (err) {
          return interaction.reply(`âŒ Erreur lors du unban: ${err.message}`);
        }
      }
    }

    if (interaction.isStringSelectMenu()) {
      if (interaction.customId.startsWith('mute_')) {
        const userId = interaction.customId.split('_')[1];
        const member = await interaction.guild.members.fetch(userId).catch(() => null);
        
        if (!member) {
          return interaction.reply({ content: 'âŒ Utilisateur introuvable', ephemeral: true }).catch(() => {});
        }

        const sanctionMap = {
          'insulte_legere_20m': { duration: '20m', reason: 'Insulte lÃ©gÃ¨re' },
          'insulte_grave_50m': { duration: '50m', reason: 'Insulte grave' },
          'spam_1h': { duration: '1h', reason: 'Spam' },
          'pub_1h': { duration: '1h', reason: 'Pub' },
          'bdsm_2h': { duration: '2h', reason: 'BDSM' },
          'comportement_40m': { duration: '40m', reason: 'Comportement inappropriÃ©' }
        };

        const sanction = sanctionMap[interaction.values[0]];
        if (!sanction) {
          return interaction.reply({ content: 'âŒ Sanction invalide', ephemeral: true }).catch(() => {});
        }

        const duration = ms(sanction.duration);
        const success = await applyTempMute(member, duration, sanction.reason, interaction);

        if (success) {
          sendLog(interaction.guild, 'ğŸ”‡ TempMute', `ğŸ‘¤ **${member.user.tag}** mute pour **${sanction.reason}** (${sanction.duration}) par ${interaction.user.tag}`, 'Orange');
          await interaction.reply({ content: `âœ… **${member.user.tag}** a Ã©tÃ© mute pour **${sanction.reason}** (${sanction.duration})`, ephemeral: true }).catch(() => {});
        }
      }
    }
  } catch (err) {
    console.error('Erreur interactionCreate:', err.message);
    if (interaction.replied || interaction.deferred) return;
    interaction.reply({ content: 'âŒ Une erreur est survenue', ephemeral: true }).catch(() => {});
  }
});

client.login(process.env.DISCORD_TOKEN).catch(err => {
  console.error('Erreur de connexion:', err.message);
  process.exit(1);
});
